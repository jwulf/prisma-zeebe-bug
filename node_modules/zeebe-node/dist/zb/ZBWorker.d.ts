import { Chalk } from 'chalk';
import { GRPCClient } from '../lib/GRPCClient';
import * as ZB from '../lib/interfaces';
import { ZBLogger } from '../lib/ZBLogger';
import { ZBClient } from './ZBClient';
interface ZBGRPC extends GRPCClient {
    completeJobSync: any;
    activateJobsStream: any;
}
export declare class ZBWorker<WorkerInputVariables, CustomHeaderShape, WorkerOutputVariables> {
    activeJobs: number;
    gRPCClient: ZBGRPC;
    maxActiveJobs: number;
    taskType: string;
    timeout: number;
    pollCount: number;
    private closeCallback?;
    private closePromise?;
    private closing;
    private closed;
    private id;
    private taskHandler;
    private cancelWorkflowOnException;
    private zbClient;
    private logger;
    private longPoll;
    private debug;
    private restartPollingAfterLongPollTimeout?;
    private capacityEmitter;
    private keepAlive;
    private alivenessBit;
    private stalled;
    constructor({ gRPCClient, id, idColor, options, taskHandler, taskType, zbClient, }: {
        gRPCClient: any;
        id: string | null;
        taskType: string;
        taskHandler: ZB.ZBWorkerTaskHandler<WorkerInputVariables, CustomHeaderShape, WorkerOutputVariables>;
        options: ZB.ZBWorkerOptions & ZB.ZBClientOptions;
        idColor: Chalk;
        onConnectionError: ZB.ConnectionErrorHandler | undefined;
        zbClient: ZBClient;
    });
    /**
     * Returns a promise that the worker has stopped accepting tasks and
     * has drained all current active tasks. Will reject if you try to call it more than once.
     */
    close(timeout?: number): Promise<undefined>;
    work: () => void;
    completeJob(completeJobRequest: ZB.CompleteJobRequest): Promise<void>;
    log(msg: any): void;
    getNewLogger(options: ZB.ZBWorkerLoggerOptions): ZBLogger;
    private stall;
    private longPollLoop;
    private activateJobs;
    private drainOne;
    private handleJob;
}
export {};
