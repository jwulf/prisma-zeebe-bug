"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs = __importStar(require("fs"));
const got = __importStar(require("got"));
const os = require("os");
const homedir = os.homedir();
class OAuthProvider {
    constructor({ 
    /** OAuth Endpoint URL */
    url, 
    /** OAuth Audience */
    audience, clientId, clientSecret, 
    /** Cache token in memory and on filesystem? */
    cacheOnDisk, }) {
        this.tokenCache = {};
        this.url = url;
        this.audience = audience;
        this.clientId = clientId;
        this.clientSecret = clientSecret;
        this.useFileCache = cacheOnDisk;
    }
    async getToken() {
        if (this.tokenCache[this.clientId]) {
            return this.tokenCache[this.clientId].access_token;
        }
        if (this.useFileCache) {
            const cachedToken = this.fromFileCache(this.clientId);
            if (cachedToken) {
                return cachedToken.access_token;
            }
        }
        try {
            const body = JSON.stringify({
                audience: this.audience,
                client_id: this.clientId,
                client_secret: this.clientSecret,
                grant_type: 'client_credentials',
            });
            const res = await got.post(this.url, {
                body,
                headers: {
                    'content-type': 'application/json',
                },
            });
            //   console.log(res.body);
            const token = JSON.parse(res.body);
            if (this.useFileCache) {
                this.toFileCache(token);
            }
            this.tokenCache[this.clientId] = token;
            this.startExpiryTimer(token);
            return token.access_token;
        }
        catch (e) {
            throw new Error(e);
        }
    }
    fromFileCache(clientId) {
        let token;
        const tokenCachedInFile = fs.existsSync(OAuthProvider.cachedTokenFile(clientId));
        if (!tokenCachedInFile) {
            return null;
        }
        try {
            token = JSON.parse(fs.readFileSync(OAuthProvider.cachedTokenFile(clientId), 'utf8'));
            if (this.isExpired(token)) {
                return null;
            }
            this.startExpiryTimer(token);
            return token;
        }
        catch (_) {
            return null;
        }
    }
    toFileCache(token) {
        const d = new Date();
        const file = OAuthProvider.cachedTokenFile(this.clientId);
        if (!fs.existsSync(OAuthProvider.cacheDir)) {
            fs.mkdirSync(OAuthProvider.cacheDir);
        }
        fs.writeFile(file, JSON.stringify({
            ...token,
            expiry: d.setSeconds(d.getSeconds() + token.expires_in),
        }), e => {
            if (!e) {
                return;
            }
            // tslint:disable-next-line
            console.log('Error writing OAuth token to file' + file);
            // tslint:disable-next-line
            console.error(e);
        });
    }
    isExpired(token) {
        const d = new Date();
        return token.expiry <= d.setSeconds(d.getSeconds());
    }
    startExpiryTimer(token) {
        const d = new Date();
        const current = d.setSeconds(d.getSeconds());
        const validityPeriod = token.expiry - current * 1000;
        if (validityPeriod <= 0) {
            delete this.tokenCache[this.clientId];
            return;
        }
        setTimeout(() => delete this.tokenCache[this.clientId], validityPeriod);
    }
}
OAuthProvider.cacheDir = `${homedir}/.camunda`;
OAuthProvider.cachedTokenFile = (clientId) => `${OAuthProvider.cacheDir}/oauth-token-${clientId}.json`;
exports.OAuthProvider = OAuthProvider;
//# sourceMappingURL=OAuthProvider.js.map