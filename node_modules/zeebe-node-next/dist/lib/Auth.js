"use strict";
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (Object.hasOwnProperty.call(mod, k)) result[k] = mod[k];
    result["default"] = mod;
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
const fs = __importStar(require("fs"));
const got = __importStar(require("got"));
class OAuthProvider {
    constructor({ 
    /** OAuth Endpoint URL */
    url, 
    /** OAuth Audience */
    audience, clientId, clientSecret, 
    /** Cache token on filesystem? */
    cache, }) {
        this.tokenCache = new Map();
        this.url = url;
        this.audience = audience;
        this.clientId = clientId;
        this.clientSecret = clientSecret;
        this.cache = cache;
    }
    async getToken() {
        if (this.cache) {
            const cachedToken = this.fromCache(this.clientId);
            if (cachedToken) {
                return cachedToken.access_token;
            }
        }
        try {
            const res = await got.post(this.url, {
                headers: {
                    'content-type': 'application/json',
                },
                body: JSON.stringify({
                    client_id: this.clientId,
                    client_secret: this.clientSecret,
                    audience: this.audience,
                    grant_type: 'client_credentials',
                }),
            });
            //   console.log(res.body);
            const resBody = JSON.parse(res.body);
            if (this.cache) {
                this.toCache(this.clientId, resBody);
            }
            return resBody.access_token;
        }
        catch (e) {
            throw new Error(e);
        }
    }
    fromCache(clientId) {
        let token;
        if (this.tokenCache.has(clientId)) {
            return this.tokenCache.get(clientId);
        }
        if (fs.existsSync(OAuthProvider.cachedTokenFile(clientId))) {
            try {
                token = JSON.parse(fs.readFileSync(OAuthProvider.cachedTokenFile(clientId), 'utf8'));
                const d = new Date();
                if (token.expiry >= d.setSeconds(d.getSeconds())) {
                    return null;
                }
                return token;
            }
            catch (_) {
                return null;
            }
        }
        return null;
    }
    toCache(clientId, token) {
        const d = new Date();
        this.tokenCache.set(clientId, token);
        try {
            fs.writeFileSync(OAuthProvider.cachedTokenFile(clientId), JSON.stringify({
                ...token,
                expiry: d.setSeconds(d.getSeconds() + token.expires_in),
            }));
        }
        catch (_) {
            // Suppress errors
            setTimeout(() => { }, 100);
        }
    }
}
exports.OAuthProvider = OAuthProvider;
OAuthProvider.cachedTokenFile = (clientId) => `./.oauth-token-${clientId}.json`;
//# sourceMappingURL=Auth.js.map